<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decision Tree Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
        }
        
        #tree-container {
            width: 100%;
            height: 80vh;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .node {
            fill: #69b3a2;
            stroke: #333;
            stroke-width: 2px;
        }
        
        .node.highlighted {
            fill: #ff6b6b;
            stroke: #d63031;
            stroke-width: 3px;
        }
        
        .link {
            fill: none;
            stroke: #999;
            stroke-width: 2px;
        }
        
        .link.highlighted {
            stroke: #ff6b6b;
            stroke-width: 4px;
        }
        
        .node-label {
            text-anchor: middle;
            font-size: 12px;
            fill: #333;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <h1>Decision Tree Visualization</h1>
    <div id="tree-container"></div>
    
    <script>
        let treeData, instanceData;
        
        async function loadAndVisualize() {
            try {
                // Load data files
                const [tree, instance] = await Promise.all([
                    // d3.json('./data/tree.json'),
                    // d3.json('./data/instance.json')
                ]);
                
                treeData = tree;
                instanceData = instance;
                
                createVisualization();
            } catch (error) {
                console.error('Error loading data:', error);
                // Create sample data for demonstration
                createSampleData();
                createVisualization();
            }
        }
        
        function createSampleData() {
            // Sample tree structure for demonstration with more nodes
            treeData = {
                "id": "root",
                "feature": "age",
                "threshold": 30,
                "children": [
                    {
                        "id": "node1",
                        "feature": "income",
                        "threshold": 50000,
                        "children": [
                            {
                                "id": "node4",
                                "feature": "credit_score",
                                "threshold": 700,
                                "children": [
                                    {"id": "leaf1", "class": "Approved", "value": 0.9},
                                    {"id": "leaf2", "class": "Rejected", "value": 0.1}
                                ]
                            },
                            {
                                "id": "node5",
                                "feature": "employment",
                                "threshold": "stable",
                                "children": [
                                    {"id": "leaf3", "class": "Pending", "value": 0.6},
                                    {"id": "leaf4", "class": "Rejected", "value": 0.4}
                                ]
                            }
                        ]
                    },
                    {
                        "id": "node2",
                        "feature": "education",
                        "threshold": "college",
                        "children": [
                            {
                                "id": "node6",
                                "feature": "debt_ratio",
                                "threshold": 0.3,
                                "children": [
                                    {"id": "leaf5", "class": "Approved", "value": 0.8},
                                    {"id": "leaf6", "class": "Pending", "value": 0.5}
                                ]
                            },
                            {
                                "id": "node3",
                                "feature": "experience",
                                "threshold": 5,
                                "children": [
                                    {
                                        "id": "node7",
                                        "feature": "location",
                                        "threshold": "urban",
                                        "children": [
                                            {"id": "leaf7", "class": "Approved", "value": 0.95},
                                            {"id": "leaf8", "class": "Approved", "value": 0.85}
                                        ]
                                    },
                                    {
                                        "id": "node8",
                                        "feature": "savings",
                                        "threshold": 10000,
                                        "children": [
                                            {"id": "leaf9", "class": "Approved", "value": 0.75},
                                            {"id": "leaf10", "class": "Pending", "value": 0.45}
                                        ]
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        "id": "node9",
                        "feature": "marital_status",
                        "threshold": "married",
                        "children": [
                            {
                                "id": "node10",
                                "feature": "dependents",
                                "threshold": 2,
                                "children": [
                                    {"id": "leaf11", "class": "Approved", "value": 0.7},
                                    {"id": "leaf12", "class": "Pending", "value": 0.55}
                                ]
                            },
                            {
                                "id": "node11",
                                "feature": "property_owner",
                                "threshold": "yes",
                                "children": [
                                    {"id": "leaf13", "class": "Approved", "value": 0.9},
                                    {"id": "leaf14", "class": "Rejected", "value": 0.3}
                                ]
                            }
                        ]
                    }
                ]
            };
            
            // Sample instance that follows a specific path through the deeper tree
            instanceData = {
                "age": 35,
                "education": "master",
                "experience": 8,
                "location": "urban",
                "path": ["root", "node2", "node3", "node7", "leaf7"]
            };
        }
        
        function createVisualization() {
            const container = d3.select("#tree-container");
            const containerRect = container.node().getBoundingClientRect();
            const width = containerRect.width;
            const height = containerRect.height;
            
            const svg = container.append("svg")
                .attr("width", width)
                .attr("height", height);
            
            // Process tree data to get all paths and assign levels
            const allPaths = getAllPaths(treeData);
            const instancePath = instanceData.path || [];
            
            // Create node positions
            const nodePositions = calculateNodePositions(allPaths, width, height, instancePath);
            
            // Create links
            const links = createLinks(allPaths, nodePositions);
            
            // Draw links
            svg.selectAll(".link")
                .data(links)
                .enter()
                .append("line")
                .attr("class", d => `link ${isLinkHighlighted(d, instancePath) ? 'highlighted' : ''}`)
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);
            
            // Draw nodes
            const nodes = Object.values(nodePositions);
            svg.selectAll(".node")
                .data(nodes)
                .enter()
                .append("circle")
                .attr("class", d => `node ${instancePath.includes(d.id) ? 'highlighted' : ''}`)
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
                .attr("r", 8);
            
            // Add labels
            svg.selectAll(".node-label")
                .data(nodes)
                .enter()
                .append("text")
                .attr("class", "node-label")
                .attr("x", d => d.x)
                .attr("y", d => d.y + 25)
                .text(d => d.label);
        }
        
        function getAllPaths(node, currentPath = []) {
            const paths = [];
            const newPath = [...currentPath, node.id];
            
            if (!node.children || node.children.length === 0) {
                // This is a leaf node
                paths.push(newPath);
            } else {
                // Continue with children
                for (const child of node.children) {
                    paths.push(...getAllPaths(child, newPath));
                }
            }
            
            return paths;
        }
        
        function calculateNodePositions(allPaths, width, height, instancePath) {
            const positions = {};
            const margin = { top: 40, right: 40, bottom: 100, left: 40 };
            const availableWidth = width - margin.left - margin.right;
            const availableHeight = height - margin.top - margin.bottom;
            
            // Find the instance path
            let instancePathData = null;
            let otherPaths = [];
            
            for (const path of allPaths) {
                if (arraysEqual(path, instancePath)) {
                    instancePathData = path;
                } else {
                    otherPaths.push(path);
                }
            }
            
            // Position the instance path at the bottom as a straight horizontal line
            if (instancePathData) {
                const bottomY = height - margin.bottom;
                instancePathData.forEach((nodeId, nodeIndex) => {
                    const x = margin.left + (nodeIndex * (availableWidth / (instancePathData.length - 1)));
                    positions[nodeId] = {
                        id: nodeId,
                        x: x,
                        y: bottomY,
                        label: getNodeLabel(nodeId)
                    };
                });
            }
            
            // Sort other paths based on where they branch off from the main path
            const sortedOtherPaths = otherPaths.sort((pathA, pathB) => {
                const branchPointA = findBranchPoint(pathA, instancePath);
                const branchPointB = findBranchPoint(pathB, instancePath);
                
                // Paths that branch earlier should be higher (smaller y), 
                // paths that branch later should be lower (larger y)
                return branchPointA - branchPointB;
            });
            
            // Position other paths above the main line, with earlier branches higher up
            const availableSpaceAbove = availableHeight - 100; // Leave space for the main line
            sortedOtherPaths.forEach((path, pathIndex) => {
                const y = margin.top + (pathIndex * (availableSpaceAbove / Math.max(1, sortedOtherPaths.length - 1)));
                
                path.forEach((nodeId, nodeIndex) => {
                    if (!positions[nodeId]) {
                        const x = margin.left + (nodeIndex * (availableWidth / (path.length - 1)));
                        positions[nodeId] = {
                            id: nodeId,
                            x: x,
                            y: y,
                            label: getNodeLabel(nodeId)
                        };
                    }
                });
            });
            
            return positions;
        }
        
        function findBranchPoint(path, instancePath) {
            // Find at which depth this path branches off from the instance path
            let branchPoint = 0;
            const minLength = Math.min(path.length, instancePath.length);
            
            for (let i = 0; i < minLength; i++) {
                if (path[i] === instancePath[i]) {
                    branchPoint = i;
                } else {
                    break;
                }
            }
            
            return branchPoint;
        }
        
        function createLinks(allPaths, nodePositions) {
            const links = [];
            const addedLinks = new Set();
            
            allPaths.forEach(path => {
                for (let i = 0; i < path.length - 1; i++) {
                    const sourceId = path[i];
                    const targetId = path[i + 1];
                    const linkId = `${sourceId}-${targetId}`;
                    
                    if (!addedLinks.has(linkId)) {
                        addedLinks.add(linkId);
                        links.push({
                            source: nodePositions[sourceId],
                            target: nodePositions[targetId],
                            sourceId: sourceId,
                            targetId: targetId
                        });
                    }
                }
            });
            
            return links;
        }
        
        function isLinkHighlighted(link, instancePath) {
            const sourceIndex = instancePath.indexOf(link.sourceId);
            const targetIndex = instancePath.indexOf(link.targetId);
            return sourceIndex !== -1 && targetIndex !== -1 && Math.abs(sourceIndex - targetIndex) === 1;
        }
        
        function getNodeLabel(nodeId) {
            // Find node in tree data and return appropriate label
            const node = findNodeById(treeData, nodeId);
            if (node) {
                if (node.children && node.children.length > 0) {
                    return `${node.feature}`;
                } else {
                    return `${node.class || 'Leaf'}`;
                }
            }
            return nodeId;
        }
        
        function findNodeById(node, id) {
            if (node.id === id) return node;
            if (node.children) {
                for (const child of node.children) {
                    const found = findNodeById(child, id);
                    if (found) return found;
                }
            }
            return null;
        }
        
        function arraysEqual(arr1, arr2) {
            return arr1.length === arr2.length && arr1.every((val, i) => val === arr2[i]);
        }
        
        // Initialize the visualization
        loadAndVisualize();
    </script>
</body>
</html>