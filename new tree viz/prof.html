<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decision Tree Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
        }
        
        #tree-container {
            width: 1000px;
            height: 1000px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin: 0 auto;
            cursor: grab;
        }
        
        #tree-container:active {
            cursor: grabbing;
        }
        
        .node {
            stroke: #333;
            stroke-width: 2px;
            cursor: pointer;
        }
        
        .node.highlighted {
            stroke: #d63031;
            stroke-width: 3px;
        }
        
        .node:hover {
            stroke: #0984e3;
            stroke-width: 3px;
        }
        
        .link {
            fill: none;
            stroke: #999;
        }
        
        .link.highlighted {
            stroke: #ff6b6b;
        }
        
        .node-label {
            text-anchor: middle;
            font-size: auto;
            fill: #333;
            pointer-events: none;
            dominant-baseline: middle;
        }

        .controls {
            margin: 20px auto;
            width: 1000px;
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .control-label {
            font-weight: bold;
            color: #333;
            margin-right: 10px;
        }

        .data-button {
            padding: 12px 24px;
            background-color: #6c5ce7;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .data-button:hover {
            background-color: #5a4fcf;
        }

        .data-button.active {
            background-color: #fd79a8;
        }

        .data-button.active:hover {
            background-color: #e84393;
        }

        .decision-tree-tooltip {
            position: absolute;
            background-color: white;
            color: black;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            white-space: normal;
            max-width: 300px;
            line-height: 1.4;
            opacity: 1;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .tooltip-header {
            font-weight: bold;
            margin-bottom: 8px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 4px;
        }

        .tooltip-line {
            margin: 4px 0;
        }

        .tooltip-distribution {
            margin-top: 8px;
            padding-top: 4px;
            border-top: 1px solid #ddd;
        }
    </style>
</head>
<body>
    <div class="controls">
        <div class="control-group">
            <span class="control-label">Data Set:</span>
            <button id="dataset1-btn" class="data-button active" onclick="setDataset('dataset1')">
                Dataset 1
            </button>
            <button id="dataset2-btn" class="data-button" onclick="setDataset('dataset2')">
                Dataset 2
            </button>
            <button id="dataset3-btn" class="data-button" onclick="setDataset('dataset3')">
                Dataset 3
            </button>
        </div>
    </div>
    <div id="tree-container"></div>
    
    <script>
        let treeData, instanceData, hierarchyRoot;
        let currentDataset = "dataset1";
        
        // Color palette for class nodes
        const DEFAULT_COLORS = [
            "#8dd3c7",
            "#ffffb3",
            "#bebada",
            "#fb8072",
            "#80b1d3",
            "#fdb462",
            "#b3de69",
            "#fccde5",
            "#d9d9d9",
            "#bc80bd",
        ];
        
        const SPLIT_NODE_COLOR = "#cccccc";
        
        // Depth-aligned layout function - UNCHANGED
        function depthAlignedLayout(allPaths, width, height, instancePath) {
            const positions = {};
            
            // Calculate total number of unique nodes
            const allNodes = new Set();
            allPaths.forEach(path => {
                path.forEach(nodeId => allNodes.add(nodeId));
            });
            const totalNodes = allNodes.size;
            
            // Scale dimensions based on number of nodes
            const nodeScaleFactor = Math.max(1, Math.sqrt(totalNodes / 100)); // Scale factor based on node count
            const minSpacing = 100; // Minimum spacing between nodes
            const nodeSpacing = minSpacing * nodeScaleFactor;
            
            // Calculate required dimensions
            const maxDepth = Math.max(...allPaths.map(path => path.length - 1));
            const requiredWidth = (maxDepth + 1) * nodeSpacing * 2; // Extra space for horizontal spread
            const requiredHeight = allPaths.length * nodeSpacing * 1.5; // Extra space for vertical spread
            
            // Use the larger of provided dimensions or required dimensions
            const effectiveWidth = Math.max(width, requiredWidth);
            const effectiveHeight = Math.max(height, requiredHeight);
            
            const margin = { 
                top: 100 * nodeScaleFactor, 
                right: 100 * nodeScaleFactor, 
                bottom: 100 * nodeScaleFactor, 
                left: 100 * nodeScaleFactor 
            };
            
            const availableWidth = effectiveWidth - margin.left - margin.right;
            const availableHeight = effectiveHeight - margin.top - margin.bottom;
            
            // Create depth mapping: depth 0 = root, depth 1 = first level, etc.
            const depthToX = {};
            
            // Calculate x-coordinates for each depth level with better spacing
            for (let depth = 0; depth <= maxDepth; depth++) {
                depthToX[depth] = margin.left + (depth * (availableWidth / maxDepth));
            }
            
            // Position the instance path at the bottom
            const bottomY = effectiveHeight - margin.bottom;
            instancePath.forEach((nodeId, depth) => {
                positions[nodeId] = {
                    id: nodeId,
                    x: depthToX[depth],
                    y: bottomY,
                    label: getNodeLabel(nodeId)
                };
            });
            
            // Find other paths and group them
            let otherPaths = [];
            for (const path of allPaths) {
                if (!arraysEqual(path, instancePath)) {
                    otherPaths.push(path);
                }
            }
            
            // Sort other paths by branch point (where they diverge from instance path)
            const sortedOtherPaths = otherPaths.sort((pathA, pathB) => {
                const branchPointA = findBranchPoint(pathA, instancePath);
                const branchPointB = findBranchPoint(pathB, instancePath);
                return branchPointA - branchPointB;
            });
            
            // Position other paths above the instance path with scaled spacing
            const availableSpaceAbove = availableHeight - (margin.bottom * 2);
            const pathSpacing = Math.max(nodeSpacing, availableSpaceAbove / Math.max(1, sortedOtherPaths.length));
            
            sortedOtherPaths.forEach((path, pathIndex) => {
                const y = margin.top + (pathIndex * pathSpacing);
                
                path.forEach((nodeId, depth) => {
                    // Only position nodes that aren't already positioned (shared nodes with instance path)
                    if (!positions[nodeId]) {
                        positions[nodeId] = {
                            id: nodeId,
                            x: depthToX[depth], // Align with same tree depth
                            y: y,
                            label: getNodeLabel(nodeId)
                        };
                    }
                });
            });
            
            // Return positions along with the effective dimensions for the visualization
            return {
                positions: positions,
                width: effectiveWidth,
                height: effectiveHeight
            };
        }
        
        // Convert flat tree array to hierarchical structure
        function createHierarchy(flatTreeData) {
            // Create a lookup map for easy access
            const nodeMap = new Map();
            flatTreeData.forEach(node => {
                nodeMap.set(node.node_id, { ...node, children: [] });
            });
            
            // Build the hierarchy by linking parents and children
            let root = null;
            nodeMap.forEach(node => {
                if (node.node_id === 0) { // Root node
                    root = node;
                } else {
                    // Find parent and add this node as a child
                    const parent = findParent(node.node_id, nodeMap);
                    if (parent) {
                        parent.children.push(node);
                    }
                }
            });
            
            // Create D3 hierarchy
            const hierarchy = d3.hierarchy(root, d => d.children);
            
            // Apply tree layout (though we'll use our custom layout function)
            const tree = d3.tree().size([800, 600]);
            tree(hierarchy);
            
            return hierarchy;
        }
        
        // Helper function to find parent node
        function findParent(nodeId, nodeMap) {
            for (const [parentId, parentNode] of nodeMap) {
                if (parentNode.left_child === nodeId || parentNode.right_child === nodeId) {
                    return parentNode;
                }
            }
            return null;
        }
        
        // Get node by ID from hierarchy
        function getNodeById(nodeId) {
            if (!hierarchyRoot) return null;
            
            function findInHierarchy(node) {
                if (node.data.node_id === nodeId) return node.data;
                if (node.children) {
                    for (const child of node.children) {
                        const found = findInHierarchy(child);
                        if (found) return found;
                    }
                }
                return null;
            }
            
            return findInHierarchy(hierarchyRoot);
        }
        
        // Get all leaf nodes from hierarchy
        function getAllLeaves() {
            if (!hierarchyRoot) return [];
            return hierarchyRoot.leaves().map(d => d.data);
        }
        
        // Get all nodes from hierarchy
        function getAllNodes() {
            if (!hierarchyRoot) return [];
            return hierarchyRoot.descendants().map(d => d.data);
        }
        
        // Get path from root to a specific node
        function getPathToNode(targetNodeId) {
            if (!hierarchyRoot) return [];
            
            function findPath(node, path = []) {
                const currentPath = [...path, node.data.node_id];
                
                if (node.data.node_id === targetNodeId) {
                    return currentPath;
                }
                
                if (node.children) {
                    for (const child of node.children) {
                        const foundPath = findPath(child, currentPath);
                        if (foundPath.length > 0) return foundPath;
                    }
                }
                
                return [];
            }
            
            return findPath(hierarchyRoot);
        }
        
        // Get tree depth
        function getTreeDepth() {
            return hierarchyRoot ? hierarchyRoot.height : 0;
        }
        
        // Get tree statistics
        function getTreeStats() {
            if (!hierarchyRoot) return {};
            
            const allNodes = getAllNodes();
            const leaves = getAllLeaves();
            
            return {
                totalNodes: allNodes.length,
                leafNodes: leaves.length,
                internalNodes: allNodes.length - leaves.length,
                maxDepth: getTreeDepth(),
                classDistribution: getClassDistribution(leaves)
            };
        }
        
        // Get class distribution from leaf nodes
        function getClassDistribution(leaves) {
            const distribution = {};
            leaves.forEach(leaf => {
                const className = leaf.class_label || 'unknown';
                distribution[className] = (distribution[className] || 0) + 1;
            });
            return distribution;
        }
        
        // Get all unique class labels
        function getUniqueClasses() {
            const leaves = getAllLeaves();
            return [...new Set(leaves.map(leaf => leaf.class_label || 'unknown'))].sort();
        }
        
        function getNodeColor(nodeId) {
            const node = getNodeById(nodeId);
            if (!node) return SPLIT_NODE_COLOR;
            
            if (node.is_leaf) {
                // For leaf nodes, use class label to determine color
                const classLabel = node.class_label || 'unknown';
                const uniqueClasses = getUniqueClasses();
                const colorIndex = uniqueClasses.indexOf(classLabel);
                return DEFAULT_COLORS[colorIndex % DEFAULT_COLORS.length];
            } else {
                // Split nodes use the specified gray color
                return SPLIT_NODE_COLOR;
            }
        }
        
        function getStrokeWidth(sourceNodeId) {
            const node = getNodeById(sourceNodeId);
            if (!node || typeof node.n_samples !== 'number') {
                return 2; // Default stroke width
            }
            
            // Find the maximum n_samples value in the tree for normalization
            const allNodes = getAllNodes();
            const maxSamples = Math.max(...allNodes.map(n => n.n_samples || 0));
            const minSamples = Math.min(...allNodes.map(n => n.n_samples || 0));
            
            // Normalize the stroke width between 1 and 10 pixels
            const minStroke = 0.1;
            const maxStroke = 10;
            
            if (maxSamples === minSamples) {
                return (minStroke + maxStroke) / 2;
            }
            
            const normalizedWidth = minStroke + ((node.n_samples - minSamples) / (maxSamples - minSamples)) * (maxStroke - minStroke);
            return normalizedWidth;
        }

        function createTooltip() {
            return d3
                .select("body")
                .append("div")
                .attr("class", "decision-tree-tooltip")
                .style("opacity", 0);
        }

        function showTooltip(event, nodeId, tooltip) {
            const node = getNodeById(nodeId);
            if (!node) return;
            
            let tooltipContent = '<div class="tooltip-header">';
            
            if (node.is_leaf) {
                tooltipContent += `<strong>Leaf Node: ${node.class_label || 'Unknown'}</strong>`;
                tooltipContent += '</div>';
            } else {
                tooltipContent += `<strong>Split: ${node.feature_name} > ${node.threshold}</strong>`;
                tooltipContent += '</div>';
                tooltipContent += `<div class="tooltip-line">Feature Index: ${node.feature_index || 'N/A'}</div>`;
                tooltipContent += `<div class="tooltip-line">Impurity: ${node.impurity ? node.impurity.toFixed(4) : 'N/A'}</div>`;
            }
            
            
            tooltipContent += `<div class="tooltip-line">Node ID: ${node.node_id}</div>`;
            tooltipContent += `<div class="tooltip-line">Samples: ${node.n_samples || 0}</div>`;
            
            if (node.value && Array.isArray(node.value)) {
                const total = node.value.reduce((sum, val) => sum + val, 0);
                const percentages = node.value.map(val => ((val / total) * 100).toFixed(1));
                
                tooltipContent += '<div class="tooltip-distribution">';
                tooltipContent += '<div style="font-weight: bold;">Class Distribution:</div>';
                tooltipContent += `<div>[${percentages.join('%, ')}%]</div>`;
                tooltipContent += '</div>';
            }

            // Add tree statistics for root node
            if (node.node_id === 0) {
                const stats = getTreeStats();
                tooltipContent += '<div class="tooltip-distribution">';
                tooltipContent += '<div style="font-weight: bold;">Tree Statistics:</div>';
                tooltipContent += `<div>Total Nodes: ${stats.totalNodes}</div>`;
                tooltipContent += `<div>Leaf Nodes: ${stats.leafNodes}</div>`;
                tooltipContent += `<div>Max Depth: ${stats.maxDepth}</div>`;
                tooltipContent += '</div>';
            }

            tooltip
                .html(tooltipContent)
                .style("left", `${event.pageX + 15}px`)
                .style("top", `${event.pageY - 28}px`)
                .transition()
                .duration(200)
                .style("opacity", 1);
        }

        function hideTooltip(tooltip) {
            tooltip.transition()
                .duration(500)
                .style("opacity", 0);
        }
        
        function setDataset(dataset) {
            currentDataset = dataset;
            
            // Update button states
            document.querySelectorAll('.data-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            if (dataset === 'dataset1') {
                document.getElementById('dataset1-btn').classList.add('active');
            } else if (dataset === 'dataset2') {
                document.getElementById('dataset2-btn').classList.add('active');
            } else if (dataset === 'dataset3') {
                document.getElementById('dataset3-btn').classList.add('active');
            }
            
            // Reload and visualize with new dataset
            loadAndVisualize();
        }
        
        async function loadAndVisualize() {
            try {
                // Determine which files to load based on current dataset
                let treeFile, instanceFile;
                
                if (currentDataset === 'dataset1') {
                    treeFile = './data/tree.json';
                    instanceFile = './data/instance.json';
                } else if (currentDataset === 'dataset2') {
                    treeFile = './data/tree2.json';
                    instanceFile = './data/instance2.json';
                } else if (currentDataset === 'dataset3') {
                    treeFile = './data/tree3.json';
                    instanceFile = './data/instance3.json';
                }
                
                // Load data files
                const [tree, instance] = await Promise.all([
                    d3.json(treeFile),
                    d3.json(instanceFile)
                ]);
                
                // Store flat tree data for compatibility
                treeData = tree;
                instanceData = instance;
                
                // Create hierarchical structure using d3.hierarchy
                hierarchyRoot = createHierarchy(tree);
                
                // Log tree statistics for debugging
                console.log('Tree Statistics:', getTreeStats());
                
                createVisualization();
            } catch (error) {
                console.error('Error loading data:', error);
                // Display error message in the container
                const container = d3.select("#tree-container");
                container.selectAll("*").remove();
                container.append("div")
                    .style("display", "flex")
                    .style("align-items", "center")
                    .style("justify-content", "center")
                    .style("height", "100%")
                    .style("color", "#ff6b6b")
                    .style("font-size", "18px")
                    .text(`Error loading data files. Please ensure ${getDatasetFiles(currentDataset)} exist in the ./data/ directory.`);
            }            
        }
        
        function getDatasetFiles(dataset) {
            if (dataset === 'dataset1') {
                return 'tree.json and instance.json';
            } else if (dataset === 'dataset2') {
                return 'tree2.json and instance2.json';
            } else if (dataset === 'dataset3') {
                return 'tree3.json and instance3.json';
            }
            return 'the required data files';
        }
    
        function createVisualization() {
            // Clear previous visualization if any
            d3.select("#tree-container").selectAll("*").remove();
            
            const container = d3.select("#tree-container");
            const containerWidth = 1000;
            const containerHeight = 1000;
            
            // Create tooltip
            const tooltip = createTooltip();
            
            // Trace the path for the instance
            const instancePath = traceInstancePath(instanceData);
            
            // Process tree data to get all paths using the hierarchy
            const allPaths = getAllPathsFromHierarchy();
            
            // Create node positions using the depth-aligned layout (UNCHANGED)
            const layoutResult = depthAlignedLayout(allPaths, containerWidth, containerHeight, instancePath);
            const nodePositions = layoutResult.positions;
            const effectiveWidth = layoutResult.width;
            const effectiveHeight = layoutResult.height;
            
            const svg = container.append("svg")
                .attr("width", containerWidth)
                .attr("height", containerHeight)
                .attr("viewBox", `0 0 ${effectiveWidth} ${effectiveHeight}`)
                .attr("preserveAspectRatio", "xMidYMid meet");
            
            // Create a group for all zoomable content
            const g = svg.append("g");
            
            // Set up zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.9, 100])
                .on("zoom", function(event) {
                    g.attr("transform", event.transform);
                });
            
            // Apply zoom to the SVG
            svg.call(zoom);
            
            // Create links
            const links = createLinks(allPaths, nodePositions);
            
            // Draw links with stroke width based on n_samples
            g.selectAll(".link")
                .data(links)
                .enter()
                .append("line")
                .attr("class", d => `link ${isLinkHighlighted(d, instancePath) ? 'highlighted' : ''}`)
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y)
                .attr("stroke-width", d => {
                    return getStrokeWidth(d.sourceId);
                });
            
            // Draw rectangular nodes
            const nodes = Object.values(nodePositions);
            const rectWidth = 150;
            const rectHeight = 100;
            
            g.selectAll(".node")
                .data(nodes)
                .enter()
                .append("rect")
                .attr("class", d => `node ${instancePath.includes(d.id) ? 'highlighted' : ''}`)
                .attr("x", d => d.x - rectWidth/2)
                .attr("y", d => d.y - rectHeight/2)
                .attr("width", rectWidth)
                .attr("height", rectHeight)
                .attr("rx", 4)
                .attr("ry", 4)
                .attr("fill", d => getNodeColor(d.id))
                .on("mouseover", function(event, d) {
                    showTooltip(event, d.id, tooltip);
                })
                .on("mouseout", function(event, d) {
                    hideTooltip(tooltip);
                })
                .on("mousemove", function(event, d) {
                    tooltip
                        .style("left", `${event.pageX + 15}px`)
                        .style("top", `${event.pageY - 28}px`);
                });
            
            // Add labels inside the rectangles with proper line breaks
            g.selectAll(".node-label-group")
                .data(nodes)
                .enter()
                .append("g")
                .attr("class", "node-label-group")
                .each(function(d) {
                    const group = d3.select(this);
                    const lines = getNodeLabelLines(d.id);
                    
                    lines.forEach((line, index) => {
                        group.append("text")
                            .attr("class", "node-label")
                            .attr("x", d.x)
                            .attr("y", d.y + (index - (lines.length - 1) / 2) * 14)
                            .text(line);
                    });
                });
        }
        
        function traceInstancePath(instance) {
            const path = [];
            let currentNode = hierarchyRoot;
            
            while (currentNode) {
                path.push(currentNode.data.node_id);
                
                if (currentNode.data.is_leaf || !currentNode.children) {
                    break;
                }
                
                // Determine which child to follow based on instance values
                const featureName = currentNode.data.feature_name;
                const threshold = currentNode.data.threshold;
                const instanceValue = instance[featureName];
                
                // Decision logic based on feature type                
                const goLeft = instanceValue <= threshold;
                
                // Find the appropriate child using the hierarchy structure
                currentNode = currentNode.children.find(child => {
                    const childNodeId = child.data.node_id;
                    const parentData = currentNode.data;
                    
                    if (goLeft) {
                        return childNodeId === parentData.left_child;
                    } else {
                        return childNodeId === parentData.right_child;
                    }
                });
            }
            
            return path;
        }
        
        function getAllPathsFromHierarchy() {
            const paths = [];
            
            function traverseNode(node, currentPath) {
                const newPath = [...currentPath, node.data.node_id];
                
                if (node.data.is_leaf || !node.children || node.children.length === 0) {
                    paths.push(newPath);
                } else {
                    node.children.forEach(child => {
                        traverseNode(child, newPath);
                    });
                }
            }
            
            if (hierarchyRoot) {
                traverseNode(hierarchyRoot, []);
            }
            
            return paths;
        }
        
        function findBranchPoint(path, instancePath) {
            let branchPoint = 0;
            const minLength = Math.min(path.length, instancePath.length);
            
            for (let i = 0; i < minLength; i++) {
                if (path[i] === instancePath[i]) {
                    branchPoint = i;
                } else {
                    break;
                }
            }
            
            return branchPoint;
        }
        
        function createLinks(allPaths, nodePositions) {
            const links = [];
            const addedLinks = new Set();
            
            allPaths.forEach(path => {
                for (let i = 0; i < path.length - 1; i++) {
                    const sourceId = path[i];
                    const targetId = path[i + 1];
                    const linkId = `${sourceId}-${targetId}`;
                    
                    if (!addedLinks.has(linkId)) {
                        addedLinks.add(linkId);
                        links.push({
                            source: nodePositions[sourceId],
                            target: nodePositions[targetId],
                            sourceId: sourceId,
                            targetId: targetId
                        });
                    }
                }
            });
            
            return links;
        }
        
        function isLinkHighlighted(link, instancePath) {
            const sourceIndex = instancePath.indexOf(link.sourceId);
            const targetIndex = instancePath.indexOf(link.targetId);
            return sourceIndex !== -1 && targetIndex !== -1 && Math.abs(sourceIndex - targetIndex) === 1;
        }
        
        function getNodeLabel(nodeId) {
            const node = getNodeById(nodeId);
            if (node) {
                if (node.is_leaf) {
                    return node.class_label;
                } else {
                    return `${node.feature_name} > ${node.threshold}\nInstance: ${instanceData[node.feature_name]}`;
                }
            }
            return `Node ${nodeId}`;
        }
        
        function getNodeLabelLines(nodeId) {
            const node = getNodeById(nodeId);
            if (node) {
                if (node.is_leaf) {
                    return [node.class_label || 'Unknown'];
                } else {
                    return [
                        `${node.feature_name} > ${parseFloat(node.threshold).toFixed(3)}`,
                        `Instance: ${instanceData[node.feature_name]}`
                    ];
                }
            }
            return [`Node ${nodeId}`];
        }
        
        function arraysEqual(arr1, arr2) {
            return arr1.length === arr2.length && arr1.every((val, i) => val === arr2[i]);
        }
        
        // Initialize the visualization
        loadAndVisualize();
    </script>
</body>
</html>