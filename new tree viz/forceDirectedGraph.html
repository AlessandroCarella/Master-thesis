<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decision Tree Force-Directed Graph</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding: 20px;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
        }
        
        .dataset-selector {
            margin-bottom: 20px;
            text-align: center;
        }
        
        .dataset-selector label {
            font-weight: bold;
            color: #555;
            margin-right: 10px;
        }
        
        .dataset-selector select {
            padding: 8px 15px;
            border: 2px solid #ddd;
            border-radius: 5px;
            background: white;
            font-size: 14px;
            cursor: pointer;
        }
        
        .dataset-selector select:focus {
            outline: none;
            border-color: #4a90e2;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        label {
            font-weight: bold;
            color: #555;
        }
        
        input[type="range"] {
            width: 100px;
        }
        
        #graph {
            border: 1px solid #ddd;
            border-radius: 5px;
            background: white;
        }
        
        .node {
            cursor: pointer;
            stroke: #fff;
            stroke-width: 2px;
        }
        
        .node.decision {
            fill: #4a90e2;
        }
        
        .node.leaf-class_0 {
            fill: #e74c3c;
        }
        
        .node.leaf-class_1 {
            fill: #2ecc71;
        }
        
        .node.leaf-class_2 {
            fill: #f39c12;
        }
        
        .node.fixed-path {
            stroke: #ff6b35;
            stroke-width: 4px;
            stroke-dasharray: 3,3;
        }
        
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 2px;
        }
        
        .link.fixed-path {
            stroke: #ff6b35;
            stroke-width: 4px;
            stroke-opacity: 1;
        }
        
        .node-label {
            font-size: 10px;
            text-anchor: middle;
            pointer-events: none;
            fill: #333;
            font-weight: bold;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            max-width: 300px;
            z-index: 1000;
        }
        
        .legend {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 0 3px rgba(0,0,0,0.3);
        }
        
        .status {
            text-align: center;
            margin: 20px 0;
            font-style: italic;
            color: #666;
        }
        
        .loading {
            color: #4a90e2;
        }
        
        .error {
            color: #e74c3c;
        }
        
        .success {
            color: #2ecc71;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Decision Tree Force-Directed Graph</h1>
        
        <div class="dataset-selector">
            <label for="datasetSelect">Choose Dataset:</label>
            <select id="datasetSelect">
                <option value="dataset1">Dataset 1 (tree.json + instance.json)</option>
                <option value="dataset2">Dataset 2 (tree2.json + instance2.json)</option>
                <option value="dataset3">Dataset 3 (tree3.json + instance3.json)</option>
            </select>
        </div>
        
        <div id="status" class="status">Select a dataset to begin visualization.</div>
        
        <div class="controls" style="display: none;" id="controls">
            <div class="control-group">
                <label for="chargeSlider">Node Repulsion:</label>
                <input type="range" id="chargeSlider" min="-500" max="-50" value="-150" />
                <span id="chargeValue">-150</span>
            </div>
            <div class="control-group">
                <label for="linkSlider">Link Distance:</label>
                <input type="range" id="linkSlider" min="20" max="200" value="80" />
                <span id="linkValue">80</span>
            </div>
            <div class="control-group">
                <label for="collisionSlider">Collision Radius:</label>
                <input type="range" id="collisionSlider" min="10" max="50" value="25" />
                <span id="collisionValue">25</span>
            </div>
        </div>
        
        <div id="graph-container" style="display: none;">
            <svg id="graph" width="1160" height="600"></svg>
        </div>
        
        <div class="legend" id="legend" style="display: none;">
            <div class="legend-item">
                <div class="legend-color" style="background-color: #4a90e2;"></div>
                <span>Decision Node</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #e74c3c;"></div>
                <span>Class 0 (Leaf)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #2ecc71;"></div>
                <span>Class 1 (Leaf)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #f39c12;"></div>
                <span>Class 2 (Leaf)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: transparent; border: 3px dashed #ff6b35;"></div>
                <span>Instance Path</span>
            </div>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>

    <script>
        let simulation;
        let svg, g;
        let nodes = [];
        let links = [];
        let fixedPath = [];
        let fixedPathLinks = [];
        let treeData = [];
        let instanceData = {};
        let nodeMap = new Map();
        let currentDataset = 'dataset1';
        
        // Initialize SVG
        svg = d3.select("#graph");
        const width = +svg.attr("width");
        const height = +svg.attr("height");
        
        g = svg.append("g");
        
        // Add zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 3])
            .on("zoom", function(event) {
                g.attr("transform", event.transform);
            });
        
        svg.call(zoom);
        
        // Tooltip
        const tooltip = d3.select("#tooltip");
        
        // Dataset selector handler
        document.getElementById('datasetSelect').addEventListener('change', function(event) {
            currentDataset = event.target.value;
            loadAndVisualize();
        });
        
        // Control handlers
        const chargeSlider = document.getElementById('chargeSlider');
        const linkSlider = document.getElementById('linkSlider');
        const collisionSlider = document.getElementById('collisionSlider');
        
        chargeSlider.addEventListener('input', function() {
            document.getElementById('chargeValue').textContent = this.value;
            if (simulation) {
                simulation.force("charge").strength(+this.value);
                simulation.alpha(0.3).restart();
            }
        });
        
        linkSlider.addEventListener('input', function() {
            document.getElementById('linkValue').textContent = this.value;
            if (simulation) {
                simulation.force("link").distance(+this.value);
                simulation.alpha(0.3).restart();
            }
        });
        
        collisionSlider.addEventListener('input', function() {
            document.getElementById('collisionValue').textContent = this.value;
            if (simulation) {
                simulation.force("collision").radius(+this.value);
                simulation.alpha(0.3).restart();
            }
        });
        
        async function loadAndVisualize() {
            try {
                const statusElement = document.getElementById('status');
                statusElement.className = 'status loading';
                statusElement.textContent = `Loading ${currentDataset}...`;
                
                // Determine which files to load based on current dataset
                let treeFile, instanceFile;
                
                if (currentDataset === 'dataset1') {
                    treeFile = './data/tree.json';
                    instanceFile = './data/instance.json';
                } else if (currentDataset === 'dataset2') {
                    treeFile = './data/tree2.json';
                    instanceFile = './data/instance2.json';
                } else if (currentDataset === 'dataset3') {
                    treeFile = './data/tree3.json';
                    instanceFile = './data/instance3.json';
                }
                
                // Load data files
                const [tree, instance] = await Promise.all([
                    d3.json(treeFile),
                    d3.json(instanceFile)
                ]);
                
                treeData = tree;
                instanceData = instance;
                
                // Create node lookup map
                nodeMap = new Map();
                treeData.forEach(node => {
                    nodeMap.set(node.node_id, node);
                });
                
                // Process and visualize the data
                processTreeData();
                
                statusElement.className = 'status success';
                statusElement.textContent = `Successfully loaded ${currentDataset} with ${treeData.length} nodes!`;
                document.getElementById('controls').style.display = 'flex';
                document.getElementById('graph-container').style.display = 'block';
                document.getElementById('legend').style.display = 'flex';
                
            } catch (error) {
                console.error('Error loading data:', error);
                const statusElement = document.getElementById('status');
                statusElement.className = 'status error';
                statusElement.textContent = `Error loading ${currentDataset}: ${error.message}`;
                
                // Hide controls and graph on error
                document.getElementById('controls').style.display = 'none';
                document.getElementById('graph-container').style.display = 'none';
                document.getElementById('legend').style.display = 'none';
            }
        }
        
        function processTreeData() {
            // Create nodes array
            nodes = treeData.map(node => ({
                id: node.node_id,
                feature_name: node.feature_name,
                threshold: node.threshold,
                is_leaf: node.is_leaf,
                class_label: node.class_label,
                n_samples: node.n_samples,
                impurity: node.impurity,
                value: node.value,
                left_child: node.left_child,
                right_child: node.right_child
            }));
            
            // Create links array
            links = [];
            treeData.forEach(node => {
                if (node.left_child !== null) {
                    links.push({
                        source: node.node_id,
                        target: node.left_child,
                        type: 'left'
                    });
                }
                if (node.right_child !== null) {
                    links.push({
                        source: node.node_id,
                        target: node.right_child,
                        type: 'right'
                    });
                }
            });
            
            // Find the path for the specific instance
            findInstancePath();
            
            createForceGraph();
        }
        
        function findInstancePath() {
            fixedPath = [];
            fixedPathLinks = [];
            
            // Start from root (node_id = 0)
            let currentNode = nodes.find(n => n.id === 0);
            if (!currentNode) {
                console.error('Root node not found');
                return;
            }
            
            fixedPath.push(currentNode);
            
            // Follow the path that the instance would take
            while (!currentNode.is_leaf) {
                const featureName = currentNode.feature_name;
                const threshold = currentNode.threshold;
                const featureValue = instanceData[featureName];
                
                if (featureValue === undefined) {
                    console.warn(`Feature ${featureName} not found in instance data`);
                    break;
                }
                
                let nextNodeId;
                
                // Determine which path to take based on the threshold
                if (featureValue <= threshold) {
                    nextNodeId = currentNode.left_child;
                } else {
                    nextNodeId = currentNode.right_child;
                }
                
                if (nextNodeId === null) break;
                
                const nextNode = nodes.find(n => n.id === nextNodeId);
                if (!nextNode) {
                    console.warn(`Node ${nextNodeId} not found`);
                    break;
                }
                
                // Add link to fixed path
                const link = links.find(l => l.source === currentNode.id && l.target === nextNodeId);
                if (link) fixedPathLinks.push(link);
                
                fixedPath.push(nextNode);
                currentNode = nextNode;
            }
            
            // Mark fixed path nodes and links
            fixedPath.forEach(node => node.isFixedPath = true);
            fixedPathLinks.forEach(link => link.isFixedPath = true);
            
            // Position fixed path nodes in a vertical line
            const pathLength = fixedPath.length;
            const startY = height * 0.2;
            const endY = height * 0.8;
            const startX = width * 0.3;
            
            fixedPath.forEach((node, index) => {
                node.fx = startX;
                node.fy = startY + (endY - startY) * (index / Math.max(pathLength - 1, 1));
            });
        }
        
        function createForceGraph() {
            // Clear previous graph
            g.selectAll("*").remove();
            
            // Create simulation
            simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links)
                    .id(d => d.id)
                    .distance(+linkSlider.value))
                .force("charge", d3.forceManyBody()
                    .strength(+chargeSlider.value))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collision", d3.forceCollide()
                    .radius(+collisionSlider.value));
            
            // Create links
            const link = g.append("g")
                .selectAll("line")
                .data(links)
                .enter().append("line")
                .attr("class", d => d.isFixedPath ? "link fixed-path" : "link")
                .style("stroke-dasharray", d => {
                    if (d.isFixedPath) return "0";
                    return d.type === 'left' ? "0" : "5,5";
                });
            
            // Create nodes
            const node = g.append("g")
                .selectAll("circle")
                .data(nodes)
                .enter().append("circle")
                .attr("class", d => {
                    let classes = "";
                    if (d.is_leaf) {
                        classes = `node leaf-${d.class_label}`;
                    } else {
                        classes = "node decision";
                    }
                    if (d.isFixedPath) {
                        classes += " fixed-path";
                    }
                    return classes;
                })
                .attr("r", d => Math.sqrt(d.n_samples) * 2 + 5)
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended))
                .on("mouseover", function(event, d) {
                    showTooltip(event, d);
                })
                .on("mouseout", hideTooltip);
            
            // Add labels
            const labels = g.append("g")
                .selectAll("text")
                .data(nodes)
                .enter().append("text")
                .attr("class", "node-label")
                .text(d => {
                    if (d.is_leaf) {
                        return d.class_label.replace('class_', 'C');
                    } else {
                        return d.feature_name ? d.feature_name.substring(0, 8) + (d.feature_name.length > 8 ? '...' : '') : 'Node';
                    }
                });
            
            // Update positions on simulation tick
            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
                
                node
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);
                
                labels
                    .attr("x", d => d.x)
                    .attr("y", d => d.y + 4);
            });
        }
        
        function showTooltip(event, d) {
            let content = `<strong>Node ${d.id}</strong><br/>`;
            content += `Samples: ${d.n_samples}<br/>`;
            
            if (d.is_leaf) {
                content += `<strong>Leaf Node</strong><br/>`;
                content += `Class: ${d.class_label}<br/>`;
                content += `Class Distribution: [${d.value.join(', ')}]`;
            } else {
                content += `<strong>Decision Node</strong><br/>`;
                content += `Feature: ${d.feature_name}<br/>`;
                content += `Threshold: ${d.threshold.toFixed(3)}<br/>`;
                content += `Impurity: ${d.impurity.toFixed(3)}<br/>`;
                content += `Class Distribution: [${d.value.join(', ')}]`;
                
                // Show instance value and decision for fixed path nodes
                if (d.isFixedPath && instanceData[d.feature_name] !== undefined) {
                    const instanceValue = instanceData[d.feature_name];
                    const decision = instanceValue <= d.threshold ? "LEFT" : "RIGHT";
                    content += `<br/><strong style="color: #ff6b35;">Instance Value: ${instanceValue}</strong>`;
                    content += `<br/><strong style="color: #ff6b35;">Decision: Go ${decision}</strong>`;
                }
            }
            
            if (d.isFixedPath) {
                content += `<br/><strong style="color: #ff6b35;">Instance Path Node</strong>`;
            }
            
            tooltip
                .style("opacity", 1)
                .html(content)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 10) + "px");
        }
        
        function hideTooltip() {
            tooltip.style("opacity", 0);
        }
        
        function dragstarted(event, d) {
            // Don't allow dragging of fixed path nodes
            if (d.isFixedPath) return;
            
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(event, d) {
            // Don't allow dragging of fixed path nodes
            if (d.isFixedPath) return;
            
            d.fx = event.x;
            d.fy = event.y;
        }
        
        function dragended(event, d) {
            // Don't allow dragging of fixed path nodes
            if (d.isFixedPath) return;
            
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
        
        // Load the initial dataset
        loadAndVisualize();
    </script>
</body>
</html>