<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dependency Cruiser Graph Visualization</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      font-family: system-ui, sans-serif;
      background: #23272f;
      color: #e6e6e6;
    }
    h2 { margin: 16px 0 8px; }
    #uploader {
      margin: 24px auto 0 auto;
      max-width: 600px;
      background: #1a1c22;
      padding: 18px 32px 18px 32px;
      border-radius: 18px;
      text-align: center;
      box-shadow: 0 8px 32px #1118 0 1px 0 #fff2 inset;
    }
    #uploader input[type="file"] {
      display: none;
    }
    #drop-area {
      border: 2px dashed #444;
      border-radius: 12px;
      padding: 28px;
      background: #23242b;
      margin: 14px 0 0 0;
      cursor: pointer;
      color: #aaa;
      font-size: 18px;
      transition: background 0.2s, border 0.2s;
    }
    #drop-area.dragover {
      background: #202633;
      border-color: #388bfd;
      color: #fff;
    }
    #graph-container {
      width: 100vw;
      height: 70vh;
      margin: 18px 0 0 0;
      overflow: hidden;
      background: #181a1f;
      border-radius: 18px;
      box-shadow: 0 4px 32px #111c;
      position: relative;
      min-height: 400px;
      min-width: 300px;
    }
    .node circle {
      fill: #50b5ff;
      stroke: #fff;
      stroke-width: 2px;
      cursor: pointer;
      transition: fill 0.15s, stroke 0.15s;
    }
    .node text {
      pointer-events: none;
      fill: #fff;
      font-size: 14px;
      text-shadow: 1px 1px 5px #0009;
    }
    .node.orphan circle {
      fill: #888 !important;
    }
    .node.highlighted circle {
      fill: #ffbe1a !important;
      stroke: #fff600 !important;
      stroke-width: 3.5px;
    }
    .node.circular circle {
      fill: #fe5b4f !important;
      stroke: #fff;
      stroke-width: 3px;
    }
    .link {
      stroke: #a1bffb;
      stroke-width: 1.9px;
      marker-end: url(#arrowhead);
      opacity: 0.76;
      transition: stroke 0.1s;
    }
    .link.circular {
      stroke: #fe5b4f;
      opacity: 1;
    }
    .link.highlighted {
      stroke: #ffbe1a !important;
      stroke-width: 2.8px;
      opacity: 1 !important;
    }
    #legend {
      position: absolute;
      bottom: 22px;
      left: 20px;
      background: #111a;
      border-radius: 10px;
      padding: 7px 16px 7px 14px;
      font-size: 14px;
      color: #eee;
      z-index: 3;
      box-shadow: 0 2px 16px #1118;
      pointer-events: none;
    }
    #legend span {
      margin-right: 22px;
    }
    #legend .legend-circular {
      color: #fe5b4f;
      font-weight: bold;
    }
    #legend .legend-orphan {
      color: #aaa;
      font-weight: bold;
    }
    #legend .legend-highlight {
      color: #ffbe1a;
      font-weight: bold;
    }
    #tooltip {
      position: absolute;
      padding: 8px 14px;
      background: #21293b;
      color: #fff;
      border-radius: 8px;
      pointer-events: none;
      box-shadow: 0 2px 12px #111a;
      font-size: 14px;
      opacity: 0;
      z-index: 10;
      transition: opacity 0.2s;
    }
  </style>
</head>
<body>
  <div id="uploader">
    <h2>Dependency Cruiser Graph Visualization</h2>
    <label id="drop-area">
      <input type="file" accept=".json">
      Drag & drop a <b>Dependency Cruiser JSON</b> here or click to browse.
    </label>
    <div style="margin-top: 10px;font-size:13px;opacity:0.8;">
      (Tip: You can export this from <code>dependency-cruiser</code> with <code>--output-type json</code>)
    </div>
  </div>

  <div id="graph-container"></div>
  <div id="legend" style="display:none">
    <span><b>Legend:</b></span>
    <span><span class="legend-circular">Red</span>: Circular Dependency</span>
    <span><span class="legend-orphan">Gray</span>: Orphan Module</span>
    <span><span class="legend-highlight">Yellow</span>: Highlighted/Selected</span>
  </div>
  <div id="tooltip"></div>

<script>
  // Utility to parse Dependency Cruiser JSON and return {nodes, links, cycles}
  function parseDepCruiserJSON(json) {
    const modules = json.modules;
    const cycles = new Set();

    // Mark circular dependencies from summary
    if (json.summary && Array.isArray(json.summary.violations)) {
      for (const v of json.summary.violations) {
        if (v.type === "cycle" && v.cycle) {
          for (const c of v.cycle) cycles.add(c.name);
        }
      }
    }

    // Build node map: name => node
    const nodeMap = {};
    modules.forEach(mod => {
      nodeMap[mod.source] = {
        id: mod.source,
        orphan: !!mod.orphan,
        circular: cycles.has(mod.source),
        valid: mod.valid
      };
    });

    // Build links
    const links = [];
    for (const mod of modules) {
      for (const dep of mod.dependencies) {
        links.push({
          source: mod.source,
          target: dep.resolved,
          circular: !!dep.circular || cycles.has(mod.source) && cycles.has(dep.resolved)
        });
      }
    }

    // Final node list with possible cycle/circular info
    const nodes = Object.values(nodeMap).map(node => ({
      ...node,
      circular: node.circular // highlight circulars
    }));

    return { nodes, links, cycles: Array.from(cycles) };
  }

  // Draws the force-directed graph using D3
  function drawGraph({nodes, links}) {
    const width = document.getElementById("graph-container").offsetWidth || 900;
    const height = document.getElementById("graph-container").offsetHeight || 700;

    d3.select("#graph-container").selectAll("*").remove();

    const svg = d3.select("#graph-container")
      .append("svg")
      .attr("width", width)
      .attr("height", height)
      .call(d3.zoom()
        .scaleExtent([0.18, 3])
        .on("zoom", (e) => g.attr("transform", e.transform)))
      .style("cursor", "grab");

    const g = svg.append("g");

    // Marker arrow for links
    svg.append("defs").append("marker")
      .attr("id", "arrowhead")
      .attr("viewBox", "-0 -5 10 10")
      .attr("refX", 18)
      .attr("refY", 0)
      .attr("orient", "auto")
      .attr("markerWidth", 6)
      .attr("markerHeight", 6)
      .attr("xoverflow", "visible")
      .append("svg:path")
        .attr("d", "M0,-5L10,0L0,5")
        .attr("fill", "#a1bffb")
        .attr("opacity", "0.92");

    // D3 force simulation
    const simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).id(d => d.id).distance(75).strength(0.7))
      .force("charge", d3.forceManyBody().strength(-330))
      .force("center", d3.forceCenter(width/2, height/2))
      .force("collision", d3.forceCollide().radius(35));

    // Draw links (arrows)
    const link = g.selectAll(".link")
      .data(links)
      .enter().append("line")
      .attr("class", d => "link" + (d.circular ? " circular" : ""))
      .attr("marker-end", "url(#arrowhead)");

    // Draw nodes
    const node = g.selectAll(".node")
      .data(nodes)
      .enter().append("g")
      .attr("class", d =>
        "node" +
        (d.orphan ? " orphan" : "") +
        (d.circular ? " circular" : ""))
      .call(drag(simulation));

    node.append("circle")
      .attr("r", 20)
      .on("mouseover", handleNodeMouseOver)
      .on("mouseout", handleNodeMouseOut)
      .on("click", handleNodeClick);

    node.append("text")
      .attr("dy", 4)
      .attr("text-anchor", "middle")
      .text(d => basename(d.id));

    // Tooltip handling
    const tooltip = d3.select("#tooltip");

    function handleNodeMouseOver(e, d) {
      d3.select(this.parentNode).classed("highlighted", true);
      link.classed("highlighted", l => l.source.id === d.id || l.target.id === d.id);
      tooltip
        .style("opacity", 1)
        .html(
          `<b>${d.id}</b><br>`
          + (d.orphan ? "<span style='color:#aaa;'>[Orphan]</span><br>" : "")
          + (d.circular ? "<span style='color:#fe5b4f;'>[Circular]</span><br>" : "")
        );
    }
    function handleNodeMouseOut(e, d) {
      d3.selectAll(".node").classed("highlighted", false);
      link.classed("highlighted", false);
      tooltip.style("opacity", 0);
    }
    function handleNodeClick(e, d) {
      // Center/zoom to the clicked node
      const t = d3.zoomIdentity
        .translate(width/2 - d.x*1.1, height/2 - d.y*1.1)
        .scale(1.1);
      svg.transition().duration(480).call(
        d3.zoom().transform,
        t
      );
    }
    svg.on("mousemove", function(e) {
      const [x, y] = d3.pointer(e, this);
      tooltip.style("left", (x + 20) + "px").style("top", (y - 6) + "px");
    });

    simulation.on("tick", () => {
      link
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

      node.attr("transform", d => `translate(${d.x},${d.y})`);
    });

    window.addEventListener("resize", () => {
      const w = document.getElementById("graph-container").offsetWidth;
      const h = document.getElementById("graph-container").offsetHeight;
      svg.attr("width", w).attr("height", h);
      simulation.force("center", d3.forceCenter(w/2, h/2)).alpha(0.08).restart();
    });
  }

  // --- Helpers ---
  function drag(simulation) {
    function dragstarted(event, d) {
      if (!event.active) simulation.alphaTarget(0.18).restart();
      d.fx = d.x; d.fy = d.y;
    }
    function dragged(event, d) {
      d.fx = event.x; d.fy = event.y;
    }
    function dragended(event, d) {
      if (!event.active) simulation.alphaTarget(0);
      d.fx = null; d.fy = null;
    }
    return d3.drag()
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended);
  }
  function basename(path) {
    const m = path.match(/([^/\\]+)$/);
    return m ? m[1] : path;
  }

  // --- File Upload/Drag-n-drop Logic ---
  const dropArea = document.getElementById("drop-area");
  const fileInput = dropArea.querySelector('input[type="file"]');
  const legend = document.getElementById("legend");

  dropArea.addEventListener('click', () => fileInput.click());

  ['dragenter', 'dragover'].forEach(eventName =>
    dropArea.addEventListener(eventName, e => {
      e.preventDefault(); e.stopPropagation();
      dropArea.classList.add('dragover');
    }, false)
  );
  ['dragleave', 'drop'].forEach(eventName =>
    dropArea.addEventListener(eventName, e => {
      e.preventDefault(); e.stopPropagation();
      dropArea.classList.remove('dragover');
    }, false)
  );
  dropArea.addEventListener('drop', handleDrop, false);
  fileInput.addEventListener('change', e => {
    if (e.target.files.length) handleFile(e.target.files[0]);
  });
  function handleDrop(e) {
    if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
  }
  function handleFile(file) {
    if (!file.name.endsWith(".json")) {
      alert("Please upload a Dependency Cruiser JSON file.");
      return;
    }
    const reader = new FileReader();
    reader.onload = function(e) {
      try {
        const data = JSON.parse(e.target.result);
        const {nodes, links} = parseDepCruiserJSON(data);
        if (nodes.length === 0 || links.length === 0) throw "No nodes or links found";
        legend.style.display = "";
        drawGraph({nodes, links});
      } catch (err) {
        alert("Invalid Dependency Cruiser JSON.\n" + err);
      }
    }
    reader.readAsText(file);
  }

  // Optionally: draw demo graph if no file is loaded (with your example)
  window.addEventListener('DOMContentLoaded', () => {
    fetch('deps.json').then(res => res.json()).then(data => {
      // If running from local filesystem, the fetch will fail (unless deps.json is present).
      try {
        const {nodes, links} = parseDepCruiserJSON(data);
        if (nodes.length && links.length) {
          legend.style.display = "";
          drawGraph({nodes, links});
        }
      } catch {}
    }).catch(()=>{});
  });
</script>
</body>
</html>
